# 递归解决分鱼问题
"""
A、B、C、D、E这5个人合伙夜间捕鱼，凌晨时都已经疲惫不堪，于是各自在河边的树丛中找地方睡着了。
第二天日上三竿时，A第一个醒来，他将鱼平分为5份，把多余的一条扔回河中，然后拿着自己的一份回家去了；
B第二个醒来，但不知道A已经拿走了一份鱼，于是他将剩下的鱼平分为5份，扔掉多余的一条，然后只拿走了自己的一份；
接着C、D、E依次醒来，也都按同样的办法分鱼。问这5个人至少合伙捕到多少条鱼？每个人醒来后所看到的鱼是多少条？
"""
# 至少的话，也就是E至少有6条鱼，分完后剩下4条鱼，才可以做到每人一条，还扔一条到河里，正好分完。可以用递归实现。
def fish(n,i): # i是5的倍数，保证之前的每次分割都可以被5整除
    if n==5:
        return 6+5*i # 得到最后一个人分割之前的鱼的数量
    elif (fish(n+1,i)-1)%5==0 and fish(n+1,i)%4==0: # 可以成功分割说明分割前的鱼减一可以被五整除，同时，分割后剩下的鱼可以被4整除，不符合的直接返回0
        return (fish(n+1,i))/4*5+1
    else:
        return 0

if __name__ == '__main__':
    i = 0
    while True:
        if fish(1, i)==0: # 如果不符合就增加i
            i += 1
        else:
            print(fish(1, i))
            break



#x = ((m-1)//5)*4
#m = x/4*5+1
'''

# 不过书上的解法一点都不直观，他的思路是，用递归来判断是否五次分割都能被5整除，如都可以了，那么这个值就是初始的值，并且是最小的，因为从6开始累加5
#     
# 我需要一个函数，判断当前这个人分割前的鱼的数量减1可以被5整除
# n表示第几个人，x表示分割前的总鱼数
def fish2(n, x): 
    if (x-1)%5==0:
        if n==1:
            return 1 # 返回1就是true的意思
        else:
            return fish2(n-1, (x-1)//5*4)
    return 0
    
if __name__ == '__main__':
    x = 6
    flag = 0
    i = 1
    while True:
        if flag != 1:
            i += 1
            x = i*5+1

            if fish2(5, x):
                flag = 1
                break
            
    print(x)


        
    '''